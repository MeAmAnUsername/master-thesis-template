% !TEX root = document.tex

\chapter{\label{chap:problem_analysis}Problem analysis}

TODO: In this chapter:
\begin{itemize}
  \item Use case: Spoofax pipelines
  \begin{itemize}
    \item What is language development?
    \item What is Spoofax? (also explains the Spoofax Ecosystem, e.g. SDF3, NaBL2, Statix, Stratego)
    \item What are pipelines that we want to express with the PIE DSL?
  \end{itemize}
  \item More detailed explanations of the problems
\end{itemize}

PIE framework exists and is in active development.
It is implemented in Java so there is lots of boilerplate.

To resolve this, the PIE DSL avoids the boilerplate and adds language support for domain specific elements, e.g. paths, list comprehensions.
It still has room for improvement:
\begin{enumerate}
  \item cannot compile to Java
  \item cannot generate tasks with a dependency on something other than a task
  \item cannot compose PIE files
  \item cannot interface with Java generic classes
\end{enumerate}
\todo{write chapter}

\todo{use case. Summary: we want to run a pipeline in Spoofax, but we don't want to specify persistence and incrementality ad-hoc. This is what build systems do, but none of them are expressive and support precise dynamic dependencies}

\Ac{PIE} is a build system that aims to allow expressing pipelines with dynamic dependencies with automatic persistence and incremental execution.
It achieves this by being imperative rather than declarative: tasks can call other tasks.
\Ac{PIE} consists of the PIE framework and the \ac{PIE} \ac{DSL}.
The framework is an implementation of \ac{PIE} in Java.
The \ac{DSL} is a language developed to create a concise specification of pipelines.
The user can specify pipelines as functions that call each other.
This \ac{PIE} \ac{DSL} code is then compiled to definitions in the Java framework by the \ac{PIE} compiler.
The Java framework saves the inputs and corresponding outputs of tasks.
If a task is called with inputs that are cached, the corresponding output is returned without executing the task.

The Java framework keeps track of the task and file dependencies of tasks.
When a file changes, it can use the dependency graph to keep track of things.

\todo{Set editor to US English}



Language engineering is the discipline of designing and implementing programming languages.
Spoofax is a language workbench, i.e.\ an IDE for designing and implementing programming languages.
It brings tools that exist in regular software development to language engineering, like syntax highlighting, static analysis and a testing framework.
It allows a language developer to work on the specification of a language and have example programs of that language open at the same time.
This allows the language developer to get immediate feedback on their changes.
Spoofax will compile the language specification and parse and analyse the example programs, which allows the language developer to experiment with language features.
The goal of Spoofax is to abstract over the implementation details of implementing a language.
A language developer only has to declaratively specify the language, Spoofax will generate an implementation for a parser, static analyser, syntax highlighting and other editor tools.

Generating these implementations uses a combination of external binary programs and Java functions.
These programs and functions have dependencies on files and each other's outputs.
This means that they form pipelines.
Because Spoofax is an IDE, we would like it to give quick feedback when a language developer makes small changes to the code.
However, executing the entire pipeline is really slow (in the order of minutes).
This means that executing the entire pipeline is not an option.
Instead, results are cached and recomputed when the output changes; this is called incrementality.
In the beginning, this was done ad-hoc: every program and Java function would have its own implementation for incrementality and persistence \todo{explain persistence before here}.
This turned out to be hard to maintain: caching is already colloquially known to be one of the "fundamental problems of computer science", so reinventing the wheel each time leads to a lot of bugs.

The problem of incrementally executing programs and functions in the right order already has a solution: a build system.
Unfortunately, existing build systems did not have all features required for Spoofax pipelines.
In particular, many build systems do not support dynamic dependencies.
Dynamic dependencies are dependencies that are not known until runtime.
A well known example are C header files: it is impossible to know what header files a particular C file depends on until you parse it.
The common solution is to overapproximate the dependency: make each C file depend on \emph{every} header file.
While this makes sure that every change is picked up on by the build system, it also means that every time a header file is changed, \emph{all} C files are considered out of date, even if few or even none of those C files depend on that particular header.

To solve this, dependencies should be precise: by keeping precise track of dependencies for every task





The Spoofax ecosystem includes several DSLs, like SDF3 to specify the grammar of a language, NaBL2 and Statix to specify the static semantics, and Stratego to specify program transformations. \todo{Can I assume that readers are familiar with language engineering in general? (i.e. they don't know Spoofax, but they do know what grammar, static semantics etc. are)}
The specifications in these DSLs are combined into a language specification.
This language specification is used by Spoofax to update open editors of the user language by parsing, analysing, syntax highlighting and showing errors.
It can also be packaged into a plugin that does these things so that the user language can be used independently from Spoofax.

All of these tasks have dependencies on the specification files, other files, each other and other tasks.
Executing all tasks each time anything changes takes too long and is often not necessary: if an example program is updated, the language specification stays the same, so the language does not need to be rebuild.
Only the editor for that example program (and possibly other editors if they depend on this one) need to be reparsed and re-analysed.
The solution is incrementality: only execute the tasks with changed inputs.
If the input stays the same, return the output from cache.

Additionally, we don't want to rebuild the language each time we restart the IDE.


\Ac{PIE} is a build system that aims to allow expressing pipelines with dynamic dependencies with automatic persistence and incremental execution.
It achieves this by being imperative rather than declarative: tasks can call other tasks.
\Ac{PIE} consists of the PIE framework and the \ac{PIE} \ac{DSL}.
The framework is an implementation of \ac{PIE} in Java.
The \ac{DSL} is a language developed to create a concise specification of pipelines.
The user can specify pipelines as functions that call each other.
This \ac{PIE} \ac{DSL} code is then compiled to definitions in the Java framework by the \ac{PIE} compiler.
The Java framework saves the inputs and corresponding outputs of tasks.
If a task is called with inputs that are cached, the corresponding output is returned without executing the task.

The Java framework keeps track of the task and file dependencies of tasks.
When a file changes, it can use the dependency graph to keep track of things.

The PIE DSL is a language for expressing pipelines.
Pipelines are expressed as functions that call other functions.
While the DSL and the compiler did work, they also had several shortcomings:
\begin{enumerate}
  \item Existing compilers were not maintainable.
  \item Does not scale to larger projects, e.g. projects that consist of multiple language projects.
  \item Implemented in NaBL2, which has a few limitations in expressiveness.
  \item Limitations in expressiveness of the PIE DSL.
  \begin{enumerate}
    \item No way to express core concepts of PIE, e.g. Suppliers and Results.
    \item No way to declare injected values for tasks.
  \end{enumerate}
\end{enumerate}
