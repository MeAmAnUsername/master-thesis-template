% !TEX root = document.tex

\section{Introduction}
\label{sec:introduction}

Transforming some inputs into some outputs is often not done with a single program, but with multiple programs that have to be executed in sequence, passing the result between them.
This is called a pipeline, and for the purposes of this thesis, the steps in such a pipeline are called tasks.
For smaller projects, such a pipeline can be expressed in a shell script like a bash script or a bat script, but as the project grows such build scripts often become unmaintainable.\autocites{Hatch2018}{Moodie2006}
Additionally, the full pipeline will be executed each build, even if nothing changed.
There is a multitude of build systems that aim to resolve these problems.
\question{In your last feedback, you asked "What is a build system?". I expect my audience to know what a build system is, so what is this question asking?}
Well known examples are Make, Maven, Ant, Gradle and MSBuild.\missingref
One of the issues with shell scripts is that dependencies are implicitly encoded by the order in which steps are executed.
This does not scale well because steps that depend on each other can get arbitrarily far away from each other, which makes it hard to see the dependencies.
Build systems aim to keep build scripts maintainable by providing a concise way to express dependencies of and between tasks.
\question{Which of these examples is better?}
\begin{lstlisting}
  // runBenchmark depends on the files generated by generateTestData.
  // This is declared within the function, so this dependency is visible
  // regardless of how many functions are between these two.
  func generateTestData(outputDir: path) -> unit = {
    exec("generateData", [("dir", outputDir)]);
    provides test_data_A.txt; provides test_data_B.txt;
    unit
  }
  // ... potentially many other functions here ...
  func runBenchmark(testDir: path) -> benchMarkResults = {
    requires test_data_A.txt; requires test_data_B.txt;
    exec("benchmark", testDir)
  }
\end{lstlisting}
\begin{lstlisting}
  // before parsing the program we first 
  // need to read the file into a string
  func parseFile(file: path) -> AST = {
    val program: string = read file;
    parse(program)
  }
\end{lstlisting}
They also keep track of which inputs changed in order to build incrementally, which saves a lot of time in the case of small changes.
\begin{lstlisting}
  func main() -> unit = {
    val inputFiles: path* = walk ./lib/pieLib/ with extension "pie"
        + ./src/main/main.pie;
    val programs = [(file.getSimpleName(), parseFile(file)) | file <- inputFiles];
    val analysisResult = analyzeProject(programs);
    val compiled = [(name, compile(name, program, analysisResult)) | (name, program) <- programs];
    [writeFile(./out/java/$name.java, program) | (name, program) <- compiled];
    unit
  }
\end{lstlisting}
In the example above, the main function uses the files in the directory \filename{lib/pieLib/} and the single file \filename{src/main/main.pie}.
It parses each file individually, analyzes all files together, compiles files using the analysis results and finally writes the compiled programs to the file system.
If we now update \filename{main.pie} and rerun the build, a simple build system would parse, re-analyze and recompile everything.
A smarter build system could see that only \filename{main.pie} was updated, and could therefor parse only that file, and then run everything else for everything again, as the analysis depends on all files and therefor all compilation results depend on all files.
This at least saves us having to parse all the library files.
An even smarter build system might check if the update to \filename{main.pie} actually affected the program.
Maybe the update to main was just editing a comment, in which case the program is unchanged, and after parsing \filename{main.pie} everything is up-to-date.

\todo{explain what precise dynamic dependencies are (and why we care?)}
A build system is precise if it keeps track of the exact dependencies of a task.
A dynamic dependency is a dependency that can only be resolved at runtime.
Almost no build system supports precise dynamic dependencies in a concise way.\missingref{verify this claim, back it up with some references, or make it more specific so that it is true}
\todo{"What is PIE?"}
\Ac{PIE} does support precise dynamic dependencies.
\Ac{PIE} is implemented as a framework in Java.
As such, it has a lot of boilerplate.
Java is also poor for expressing concepts from the domain of pipelines.
To solve these issues, the \ac{PIE} \ac{DSL} was developed.
The \ac{PIE} \ac{DSL} allows a pipeline developer to express the relevant parts of a task definition in a language that allows easily expressing common concepts in pipelines.
Because the \ac{DSL} has significantly less boilerplate, it saves the developer time, is easier to read and has less duplication which improves maintainability and prevents bugs. 
The concise \ac{PIE} \ac{DSL} task definition is compiled to Java, which generates all the Java boilerplate.

While the \ac{PIE} \ac{DSL} and the compiler had implementations, they had several shortcomings:
\todo{"Describe the problems in a more general way, without pointing to specific details. Those details can be explained in the next section."}
\begin{enumerate}
  \item Existing compilers were not maintainable.
  \item The \ac{DSL} does not scale to larger projects, e.g. projects that consist of multiple language projects.
  \item The \ac{DSL} is implemented in NaBL2, which has a few limitations in expressiveness.
  \item The \ac{DSL} has limitations in expressiveness
  \begin{enumerate}
    \item No way to express core concepts of \ac{PIE}, e.g. Suppliers and Results.
    \item No way to declare injected values for tasks.\todo{"What are injected values? Too much detail => defer to problem analysis. Mention that you will go into more details about the problems in that section"}
  \end{enumerate}
\end{enumerate}

We set out to improve the \ac{PIE} \ac{DSL} with the following objectives:\todo{"Nice! Maybe it would be good to list this as non-functional requirements"}
\begin{itemize}
  \item Solve these problems
  \item Keep the \ac{PIE} \ac{DSL} general
  \begin{itemize}
    \item It could also compile to another language if another compiler and \ac{PIE} framework were written in that language.
    \item It should work for pipelines in general, not just Spoofax pipelines.
  \end{itemize}
  \item Since \ac{PIE} is meant to give realtime feedback in Spoofax, it should be reasonably performant
  \item Keep the \ac{PIE} \ac{DSL} extendable. Do not add features that are incompatible with future extensions of the language where this is reasonably possible.
\end{itemize}

In the end, this thesis [has]  the following contributions:
\todo{Before listing your contributions, describe your solution and why/that it works. Your solution should address all the problems. The contributions is just a summary of the work with references to the relevant sections. See Scalalbe incremental building paper.}
\begin{itemize}
  \item a new compiler for the DSL
  \item implemented static semantics of the \ac{DSL} in Statix
  \item Add modules, context parameters (and generics?) to the DSL
  \item Evaluate the new \ac{DSL} in three case studies:
  \begin{itemize}
    \item simple transformation from Tiger
    \item database pipelines at Oracle
    \item testing pipelines at Oracle
  \end{itemize}
  \item Evaluation of performance for generated code (?)
\end{itemize}

The rest of this thesis is set up as follows.
Section 2 gives an explanation of our use cases and explains the problems in more detail.
Section 3 lists the improvements that were made to the \ac{PIE} \ac{DSL}.
Section 4 evaluates the new \ac{DSL} with three case studies.
It also compares expressing a pipeline in the \ac{DSL} or directly in the Java framework.
Section 5 lists related work. \todo{slightly more descriptive: "puts this work into context by comparing it to solutions for similar problems"}
Section 6 concludes this thesis.
